import './test'  
执行从头到尾执行引入的js文件，当然，会忽略js文件里export。  

```javascript
// counter.js
import {a} from './my';
console.log('333333');
console.log(a);

// my.js
console.log('111111');
export var a = 'aaaaaaa';
console.log('222222');

// 转义后
//#----------------mod start----------------

void function (module, exports){
    window["60ae5ba7"] = {};
    
    "use strict";
    // my.js
    console.log('111111');
    window["60ae5ba7"].a = 'aaaaaaa';
    console.log('222222');
    
}({exports:{}}, {})


//#----------------mod end----------------

//#----------------mod start----------------

void function (module, exports){
    window["3d4fdd69"] = {};
    
    "use strict";
    // counter.js
    var my_1 = window["60ae5ba7"];
    console.log('333333');
    console.log(my_1.a);
```

ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。  即 ES6 可以在编译时就完成模块加载，在编译的时候，发现了后面有使用到a的地方，就在运行时遇到import的地方直接执行了模块的代码。

```javascript
performance.mark()
    通过一个给定的名称，将该名称（作为键）和对应的DOMHighResTimeStamp（作为值）保存在一个哈希结构里。该键值对表示了从某一时刻（译者注：某一时刻通常是 navigationStart 事件发生时刻）到记录时刻间隔的毫秒数。（译者注：该方法一般用来多次记录时间，用于求得各记录间的时间差）
```
